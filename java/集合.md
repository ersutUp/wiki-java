# <div id="set"></div>集合

## List



### ArrayList

[原理展示](./html/arraylist-visualization-single-demo.html)





## Map

用来存储键值对



### HashMap

- HashMap的大小（size变量）：key → value 的个数
- 底层的数据存储（table变量）：
  - 他是个数组`Node<K,V>[] table`
  - 默认容量是16（这个容量不是Map的大小，是底层存储数据的数组）
  - 这个数组的类型为`Node`对象
  - **💡注意容量一定是2的幂**
- 加载因子（loadFactor变量）：
  - 默认0.75（DEFAULT_LOAD_FACTOR常量）
  - 当容量超出 `size*loadFactor` 那么就开始扩容，即增加table数组的长度

#### 计算key对应的索引

> [网页演示](./html/hashmap-animation-fixed.html)

1. 通过计算key的hash值
2. 对hash值再次处理减少其冲突的概率
3. 用 处理后的hash值 与 容量 计算获取索引值

##### **计算索引的源码**

**公式：`int index = (table.length - 1) & hash;`**

存储数据的 `table` 变量的大小，初始值是16，每次扩容时，会增加一倍，即 32、64、128、256、512...... 以此类推

所以 `table` 的大小一定是 **2的幂** 

转换为2进制就是

| 十进制 | 二进制    |
| ------ | --------- |
| 160    | 0001 0000 |
| 32     | 0010 0000 |
| 64     | 0100 0000 |
| 128    | 1000 0000 |

继续看公式`table.length - 1` 

其二进制的值会变为

| 十进制    | 二进制    |
| --------- | --------- |
| 16-1=15   | 0000 1111 |
| 32-1=31   | 0001 1111 |
| 64-1=63   | 0011 1111 |
| 128-1=127 | 0111 1111 |

`&`运算 

- 1和1为1
- 0和0为0
- 0和1为0
- 1和0为0

那么不管hash值多大，高位（这里指的`table.length - 1`在二进制中的0 ）的都会清零，这样算出的结果一定不会超出`table`的长度，示例如下

|                              | 十进制  | 二进制    |
| ---------------------------- | ------- | --------- |
| `table`的长度                | 16-1=15 | 0000 1111 |
| 处理后的hash值               |         | 1011 1001 |
| 或(`&`)运算结果,也就是索引值 | 9       | 00001001  |

上面这个示例中索引定位到 9

再来一个

|                              | 十进制    | 二进制              |
| ---------------------------- | --------- | ------------------- |
| `table`的长度                | 512-1=511 | 0000 0001 1111 1111 |
| 处理后的hash值               |           | 1011 0011 1111 0111 |
| 或(`&`)运算结果,也就是索引值 | 503       | 0000 0001 1111 0111 |

上边这个示例中索引定位到 503



综上所述，**计算后的值是不会越界的**

#### 扩容

