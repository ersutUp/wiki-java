# <div id="set"></div>集合

## List



### ArrayList

[原理展示](./html/arraylist-visualization-single-demo.html)





## Map

用来存储键值对



### HashMap

- HashMap的大小（size变量）：key → value 的个数
- 底层的数据存储（table变量）：
  - 他是个数组`Node<K,V>[] table`
  - 默认容量是16（这个容量不是Map的大小，是底层存储数据的数组）
  - 这个数组的类型为`Node`对象
  - **💡注意容量一定是2的幂**
- 加载因子（loadFactor变量）：
  - 默认0.75（DEFAULT_LOAD_FACTOR常量）
  - 当容量超出 `size*loadFactor` 那么就开始扩容，即增加table数组的长度

#### 计算key对应的索引

> [网页演示](./html/hashmap-animation-fixed.html)

1. 通过计算key的hashCode值 `key.hashCode()`
2. 对hashCode值再次处理减少其冲突的概率得到hash值 `int hash = hashCode^(hashCode >>> 16)`
3. 用 hash值 与 容量 计算获取索引值 `int index = hash & (table.length - 1);`

##### **计算索引的源码**

**公式：`int index = (table.length - 1) & hash;`**

##### 💡为什么需要`table.length - 1`

存储数据的 `table` 变量的大小，初始值是16，每次扩容时，会增加一倍，即 32、64、128、256、512...... 以此类推

所以 `table` 的大小一定是 **2的幂** 

转换为2进制就是

| 十进制 | 二进制    |
| ------ | --------- |
| 160    | 0001 0000 |
| 32     | 0010 0000 |
| 64     | 0100 0000 |
| 128    | 1000 0000 |

继续看公式`table.length - 1` 

其二进制的值会变为

| 十进制    | 二进制    |
| --------- | --------- |
| 16-1=15   | 0000 1111 |
| 32-1=31   | 0001 1111 |
| 64-1=63   | 0011 1111 |
| 128-1=127 | 0111 1111 |

`&`运算 

- 1和1为1
- 0和0为0
- 0和1为0
- 1和0为0

那么不管hash值多大，高位（这里指的`table.length - 1`在二进制中的0 ）的都会清零，这样算出的结果一定不会超出`table`的长度，示例如下

|                              | 十进制  | 二进制    |
| ---------------------------- | ------- | --------- |
| `table`的长度                | 16-1=15 | 0000 1111 |
| 处理后的hash值               |         | 1011 1001 |
| 或(`&`)运算结果,也就是索引值 | 9       | 0000 1001 |

上面这个示例中索引定位到 9

再来一个

|                              | 十进制    | 二进制              |
| ---------------------------- | --------- | ------------------- |
| `table`的长度                | 512-1=511 | 0000 0001 1111 1111 |
| 处理后的hash值               |           | 1011 0011 1111 0111 |
| 或(`&`)运算结果,也就是索引值 | 503       | 0000 0001 1111 0111 |

上边这个示例中索引定位到 503



综上所述，**计算后的值是不会越界的**

#### 扩容

> 针对底层table变量（存储key、value的数组）的扩容
>
> [网页演示](./html/hashmap-resize-complete.html)

##### 相关变量

- `size`：HashMap的大小，即存储了多少个key、value
-  `threshold` ：扩容的阈值
- `loadFactor`：计算因子，用来计算扩容的阈值
- `table`：底层存储数据的数组

threshold阈值的计算 `table.length*loadFactor`，初始值(未指定容量和加载因子的情况下)为 `16*0.75`

**在HashMap的大小(size变量) 大于等于 threshold 时进行扩容，每次扩容原来容量(`table的长度`)的2倍。**



##### 扩容的流程

1. 创建新的table，长度为原来的2倍
2. 计算原table中所有元素的在新table中的新索引



##### <span id="newIndex"></span>⭐️新索引的计算

新索引的计算无需重新，因为元素的新索引只有两种可能：**与旧索引相同**，或 **旧索引 + 旧容量**（取决于哈希值的高位是否为 1）。

**旧索引 + 旧容量的情况**

| 容量                 | hash值 | 计算索引值 hash & (table.length - 1) | 扩容时计算索引  oldIndex + oldCap |
| -------------------- | ------ | ------------------------------------ | --------------------------------- |
| oldCap(旧容量)：0100 | 0110   | 0110 & 0011 = 0010                   |                                   |
| newCap(新容量)：1000 | 同上   | 0110 & 0111 = 0110                   | 0100 +  0010 = 0110               |



**与旧索引相同的情况**

| 容量                 | hash值 | 计算索引值 hash & (table.length - 1) | 扩容时计算索引（与旧索引相同） |
| -------------------- | ------ | ------------------------------------ | ------------------------------ |
| oldCap(旧容量)：0100 | 0010   | 0010 & 0011 = 0010                   |                                |
| newCap(新容量)：1000 | 同上   | 0010 & 0111 = 0010                   | 0010                           |



**如何用代码区分这两种情况**

通过 旧容量和hash值做 & 运算  `hash & oldCap` 等于0 ，则索引位置不变，否则新索引为 旧索引 + 旧容量

简易示例代码

```java
// 新索引只有两种可能：
int hash = node.hash;
int oldCap = 16;
if ((hash & oldCap) == 0) {
    新索引 = 旧索引;
} else {
    新索引 = 旧索引 + oldCap;  // 旧容量
}
```



##### 💡为什么需要扩容2倍

1. 在计算索引时 使用hash码 来计算索引位置，公式为`hash & (table.length - 1)`，其中`table.length - 1`的2进制中都为1，用 & 计算可以**提高桶的均匀分布**
2. 扩容时 重新计算索引 可以提升效率，具体看[上边](#newIndex)



##### 扩容时红黑树降级回链表情况

当链表大于8个时会转换为红黑树；

那**扩容时会重新计算索引，所以红黑树上的可能不足8个， 当小于6个时会降级回链表**。
