# <div id="set"></div>集合

## List



### <span id="arraylist"></span>ArrayList

[原理展示](./html/arraylist-visualization-single-demo.html)

初始大小：10

每次扩容1.5倍



### <span id="linkedlist"></span>LinkedList



内部维护一个双向链表



| 场景                 | ArrayList 优势       | LinkedList 优势                 |
| -------------------- | -------------------- | ------------------------------- |
| 随机访问（`get(i)`） | O (1)，高效          | O (n)，低效                     |
| 中间插入 / 删除      | O (n)（需移动元素）  | 若已知节点，O (1)（仅修改指针） |
| 尾部插入 / 删除      | O (1)（无扩容时）    | O(1)                            |
| 内存占用             | 连续空间，可能有冗余 | 分散空间，每个元素额外指针开销  |
| 遍历效率             | 高（缓存友好）       | 低（缓存不友好）                |

## Map

用来存储键值对



### <span id='HashMap' />HashMap

- HashMap的大小（size变量）：key → value 的个数
- 底层的数据存储（table变量）：
  - 他是个数组`Node<K,V>[] table`
  - 默认容量是16（这个容量不是Map的大小，是底层存储数据的数组）
  - 这个数组的类型为`Node`对象
  - **💡注意容量一定是2的幂**
- 加载因子（loadFactor变量）：
  - 默认0.75（DEFAULT_LOAD_FACTOR常量）
  - 当容量超出 `size*loadFactor` 那么就开始扩容，即增加table数组的长度

#### 计算key对应的索引

> [网页演示](./html/hashmap-animation-fixed.html)

1. 通过计算key的hashCode值 `key.hashCode()`
2. 对hashCode值再次处理减少其冲突的概率得到hash值 `int hash = hashCode^(hashCode >>> 16)`
3. 用 hash值 与 容量 计算获取索引值 `int index = hash & (table.length - 1);`

##### **计算索引的源码**

**公式：`int index = (table.length - 1) & hash;`**

##### 💡为什么需要`table.length - 1`

存储数据的 `table` 变量的大小，初始值是16，每次扩容时，会增加一倍，即 32、64、128、256、512...... 以此类推

所以 `table` 的大小一定是 **2的幂** 

转换为2进制就是

| 十进制 | 二进制    |
| ------ | --------- |
| 160    | 0001 0000 |
| 32     | 0010 0000 |
| 64     | 0100 0000 |
| 128    | 1000 0000 |

继续看公式`table.length - 1` 

其二进制的值会变为

| 十进制    | 二进制    |
| --------- | --------- |
| 16-1=15   | 0000 1111 |
| 32-1=31   | 0001 1111 |
| 64-1=63   | 0011 1111 |
| 128-1=127 | 0111 1111 |

`&`运算 

- 1和1为1
- 0和0为0
- 0和1为0
- 1和0为0

那么不管hash值多大，高位（这里指的`table.length - 1`在二进制中的0 ）的都会清零，这样算出的结果一定不会超出`table`的长度，示例如下

|                              | 十进制  | 二进制    |
| ---------------------------- | ------- | --------- |
| `table`的长度                | 16-1=15 | 0000 1111 |
| 处理后的hash值               |         | 1011 1001 |
| 或(`&`)运算结果,也就是索引值 | 9       | 0000 1001 |

上面这个示例中索引定位到 9

再来一个

|                              | 十进制    | 二进制              |
| ---------------------------- | --------- | ------------------- |
| `table`的长度                | 512-1=511 | 0000 0001 1111 1111 |
| 处理后的hash值               |           | 1011 0011 1111 0111 |
| 或(`&`)运算结果,也就是索引值 | 503       | 0000 0001 1111 0111 |

上边这个示例中索引定位到 503



综上所述，**计算后的值是不会越界的**

#### 扩容

> 针对底层table变量（存储key、value的数组）的扩容
>
> [网页演示](./html/hashmap-resize-complete.html)

##### 相关变量

- `size`：HashMap的大小，即存储了多少个key、value
-  `threshold` ：扩容的阈值
- `loadFactor`：计算因子，用来计算扩容的阈值
- `table`：底层存储数据的数组

threshold阈值的计算 `table.length*loadFactor`，初始值(未指定容量和加载因子的情况下)为 `16*0.75`

**在HashMap的大小(size变量) 大于等于 threshold 时进行扩容，每次扩容原来容量(`table的长度`)的2倍。**



##### 扩容的流程

1. 创建新的table，长度为原来的2倍
2. 计算原table中所有元素的在新table中的新索引



##### <span id="newIndex"></span>⭐️新索引的计算

新索引的计算无需重新，因为元素的新索引只有两种可能：**与旧索引相同**，或 **旧索引 + 旧容量**（取决于哈希值的高位是否为 1）。

**旧索引 + 旧容量的情况**

| 容量                 | hash值 | 计算索引值 hash & (table.length - 1) | 扩容时计算索引  oldIndex + oldCap |
| -------------------- | ------ | ------------------------------------ | --------------------------------- |
| oldCap(旧容量)：0100 | 0110   | 0110 & 0011 = 0010                   |                                   |
| newCap(新容量)：1000 | 同上   | 0110 & 0111 = 0110                   | 0100 +  0010 = 0110               |



**与旧索引相同的情况**

| 容量                 | hash值 | 计算索引值 hash & (table.length - 1) | 扩容时计算索引（与旧索引相同） |
| -------------------- | ------ | ------------------------------------ | ------------------------------ |
| oldCap(旧容量)：0100 | 0010   | 0010 & 0011 = 0010                   |                                |
| newCap(新容量)：1000 | 同上   | 0010 & 0111 = 0010                   | 0010                           |



**如何用代码区分这两种情况**

通过 旧容量和hash值做 & 运算  `hash & oldCap` 等于0 ，则索引位置不变，否则新索引为 旧索引 + 旧容量

简易示例代码

```java
// 新索引只有两种可能：
int hash = node.hash;
int oldCap = 16;
if ((hash & oldCap) == 0) {
    新索引 = 旧索引;
} else {
    新索引 = 旧索引 + oldCap;  // 旧容量
}
```



##### <span id="hashmap_2"/>💡为什么需要扩容2倍

1. 在计算索引时 使用hash码 来计算索引位置，公式为`hash & (table.length - 1)`，其中`table.length - 1`的2进制中都为1，用 & 计算可以**提高桶的均匀分布**
2. 扩容时 重新计算索引 可以提升效率，具体看[上边](#newIndex)



##### 扩容时红黑树降级回链表情况

当链表大于8个时会转换为红黑树；

那**扩容时会重新计算索引，所以红黑树上的可能不足8个， 当小于6个时会降级回链表**。



### <span  id="LinkedHashMap" />LinkedHashMap

继承自HashMap`public class LinkedHashMap<K,V> extends HashMap<K,V> implements Map<K,V>`

在HashMap的基础上维护了一个双向链表

核心代码

```java
//链表的头
transient LinkedHashMap.Entry<K,V> head;
//链表的尾
transient LinkedHashMap.Entry<K,V> tail;

// HashMap.Node 是真正存储数据的对象
static class Entry<K,V> extends HashMap.Node<K,V> {
    //增加链表的指针
    Entry<K,V> before, after;
    Entry(int hash, K key, V value, Node<K,V> next) {
        super(hash, key, value, next);
    }
}
//创建node对象
Node<K,V> newNode(int hash, K key, V value, Node<K,V> e) {
    LinkedHashMap.Entry<K,V> p =
        new LinkedHashMap.Entry<K,V>(hash, key, value, e);
    linkNodeLast(p);
    return p;
}
//添加链表的指针
private void linkNodeLast(LinkedHashMap.Entry<K,V> p) {
    LinkedHashMap.Entry<K,V> last = tail;
    tail = p;
    if (last == null)
        head = p;
    else {
        p.before = last;
        last.after = p;
    }
}
```

**`newNode`方法：`put`方法最终通过调用`newNode`方法存储的数据，所以`LinkedHashMap`重写了`newNode`方法**

